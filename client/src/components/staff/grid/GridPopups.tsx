import { Button } from 'react-bootstrap';
import * as moment from 'moment';

import { GridCellData } from 'modules/staff/grid';

type UnlockedProps = Readonly<{
    solveData: GridCellData;
    clues: any[];
    onRelock: () => void;
    onComplete: () => void;
}>;

// Handles the popup for a puzzle that is unlocked, but not solved.
export const GridUnlockedPopup = ({ solveData, clues, onRelock, onComplete }: UnlockedProps) => {
    const clue = clues.find(x => x.tableOfContentId === solveData.tableOfContentId);
    let clueText = undefined;

    if (clue?.parSolveTime) {
        clueText = `The expected solve time is ${clue.parSolveTime} minutes`;
    }

    let clueType = "activity";

    if (clue.submittableType.trim() === "Puzzle") {
        clueType = "puzzle"
    } else if (clue.submittableType.trim() === "locunlock") {
        clueType = "location"
    }

    return (
        <>
            <p>
                This {clueType} was unlocked at <em>{moment.utc(solveData.startTime).local().format('HH:mm')}</em>. Our wild
                guess is that it will be solved around <em>{moment.utc(solveData.predictedEnd).local().format('HH:mm')}</em>.
            </p>
            <p>
                The team has been at this for <em>{moment.duration(moment.utc().diff(moment.utc(solveData.startTime))).asMinutes()}</em> minutes. {clueText}
            </p>
            <p>
                {!!solveData.unlockedClues && solveData.unlockedClues.length > 0 ?
                    "Solving this will currently unlock the following: " + solveData.unlockedClues.map(unlock => " " + clues.find(x => x.submittableId === unlock).submittableTitle + " ") 
                    :
                    "Solving this will not unlock anything."}
            </p>
            <p>
                <Button onClick={() => { 
                        onRelock();
                        onComplete();
                    }}>
                    Re-Lock
                </Button>
            </p>
        </>
    );
};

type UnlockableProps = Readonly<{
    solveData: GridCellData;
    clues: any[];
    onUnlock: () => void;
    onSkip: () => void;
    onComplete: () => void;
}>;

export const GridUnlockablePopup = ({ solveData, clues, onUnlock, onSkip, onComplete }: UnlockableProps) => {
    return (
        <>
            { solveData.predictedStart ?
                <p>
                    According to our random number generated by Game Control, we believe this team
                    will unlock this puzzle at <em>{moment.utc(solveData.predictedStart).local().format('HH:mm')}</em> and solve it
                    at <em>{moment.utc(solveData.predictedEnd).local().format('HH:mm')}</em>
                </p>
                :
                <p>
                    According to our predictive algorithm this team has no path to unlocking this puzzle.
                </p>
            }
            <p>
                {solveData.unlockedClues?.length > 0 ?
                    "Solving this will currently unlock the following: " + solveData.unlockedClues.map(unlock => " " + clues.find(x => x.submittableId === unlock).title + " ") 
                    :
                    "Solving this will not unlock anything."}    
            </p>
            <p>
                <Button onClick={() => {
                        onUnlock();
                        onComplete();
                    }}>Unlock</Button>
                <Button onClick={() => {
                        onSkip();
                        onComplete();
                    }}>Skip</Button>
            </p>
        </>
    );
};
